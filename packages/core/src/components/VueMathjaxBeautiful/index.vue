<template>
  <!-- ÂÜÖËÅîÊ®°Âºè -->
  <div
    v-if="inlineMode"
    class="vue-mathjax-beautiful-inline"
    :class="{ 'theme-dark': internalTheme === 'dark', 'theme-light': internalTheme === 'light' }"
  >
    <!-- ÁºñËæëÂô®ÂÜÖÂÆπ -->
    <div class="editor-container">
      <!-- ËæìÂÖ•Âå∫Âüü -->
      <div class="input-section">
        <div class="section-header">
          <div class="section-title">
            <span class="icon">üìù</span>
            <span>{{ t.beautiful.inputSection }}</span>
          </div>
          <div class="input-actions">
            <button 
              v-if="availableLocales.length > 1"
              class="action-btn" 
              @click="toggleLanguage" 
              :title="locale === 'zh-CN' ? 'Switch to English' : 'ÂàáÊç¢Âà∞‰∏≠Êñá'"
            >
              <span class="icon">üåê</span>
            </button>
            <button 
              v-if="showThemeToggle"
              class="action-btn" 
              @click="toggleTheme" 
              :title="internalTheme === 'dark' ? t.beautiful.themeToggle.light : t.beautiful.themeToggle.dark"
            >
              <span class="icon">{{ themeIcon }}</span>
            </button>
            <button 
              v-if="showClearButton && !readonly"
              class="action-btn" 
              @click="clearInput" 
              :title="t.beautiful.clearButton"
            >
              <span class="icon">üóëÔ∏è</span>
            </button>
          </div>
        </div>
        <div class="input-wrapper">
          <textarea
            v-model="latexInput"
            class="latex-input"
            :placeholder="computedPlaceholder"
            :readonly="readonly"
            :rows="rows"
            :maxlength="maxLength"
            @input="handleInput"
          ></textarea>
        </div>
      </div>

      <!-- È¢ÑËßàÂå∫Âüü -->
      <div v-if="showPreview" class="preview-section">
        <div class="section-header">
          <div class="section-title">
            <span class="icon">üëÅÔ∏è</span>
            <span>{{ t.beautiful.previewSection }}</span>
          </div>
          <div class="preview-status" :class="{ active: latexInput }">
            <span v-if="latexInput" class="status-dot"></span>
            {{ latexInput ? t.beautiful.rendering : t.beautiful.noFormula }}
          </div>
        </div>
        <div class="preview-container">
          <div v-if="latexInput" class="formula-preview" v-html="renderedFormula"></div>
          <div v-else class="no-formula">
            <span class="icon">üí°</span>
            <span>{{ t.beautiful.inputPlaceholder }}</span>
          </div>
        </div>
      </div>

      <!-- Á¨¶Âè∑Èù¢Êùø -->
      <div v-if="showSymbols" class="symbols-section">
        <!-- ÂàÜÁ±ªÊ†áÁ≠æ -->
        <div class="category-tabs">
          <button
            v-for="category in filteredCategories"
            :key="category.key"
            :class="['tab-button', { active: activeCategory === category.key }]"
            @click="activeCategory = category.key"
          >
            <span class="tab-icon">{{ category.icon }}</span>
            <span class="tab-name">{{ getCategoryName(category, locale) }}</span>
          </button>
        </div>

        <!-- Á¨¶Âè∑ÂÜÖÂÆπ -->
        <div class="symbols-content">
          <!-- Á¨¶Âè∑ÁΩëÊ†º -->
          <div class="symbols-grid">
            <button
              v-for="symbol in currentSymbols"
              :key="symbol.latex"
              class="symbol-button"
              @click="insertSymbol(symbol.latex)"
              :title="getSymbolDescription(symbol, locale)"
            >
              <span v-if="symbol.display" v-html="symbol.display"></span>
              <span v-else class="symbol-fallback">{{ symbol.latex }}</span>
            </button>
          </div>

          <!-- Â∏∏Áî®ÂÖ¨ÂºèÁ§∫‰æã -->
          <div v-if="activeCategory === 'basic' && showFormulaExamples" class="formula-examples">
            <div class="examples-header">
              <span class="icon">‚≠ê</span>
              <span>{{ t.beautiful.categories.formulas }}</span>
            </div>
            <div class="examples-grid">
              <button
                v-for="example in reactiveFormulaExamples"
                :key="example.latex"
                class="example-button"
                @click="insertSymbol(example.latex)"
                :title="getSymbolDescription(example, locale)"
              >
                <div class="example-preview" v-html="example.display"></div>
                <div class="example-description">{{ getSymbolDescription(example, locale) }}</div>
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- Â∫ïÈÉ®Êìç‰ΩúÔºàÂÜÖËÅîÊ®°ÂºèÔºâ -->
      <div class="inline-footer">
        <button 
          v-if="showClearButton && !readonly"
          class="btn btn-secondary" 
          @click="clearInput"
        >
          {{ t.beautiful.clearButton }}
        </button>
        <button 
          class="btn btn-primary" 
          @click="handleInsert" 
          :disabled="!latexInput || readonly"
        >
          {{ t.beautiful.insertButton }}
        </button>
      </div>
    </div>
  </div>

  <!-- ÂºπÁ™óÊ®°Âºè -->
  <Teleport to="body">
  <div
      v-if="visible"
    class="vue-mathjax-beautiful-overlay"
    :class="{ 'theme-dark': internalTheme === 'dark', 'theme-light': internalTheme === 'light' }"
    @click="handleOverlayClick"
  >
    <div
      class="vue-mathjax-beautiful-dialog"
      :class="{ 'theme-dark': internalTheme === 'dark', 'theme-light': internalTheme === 'light' }"
      :style="dialogStyle"
      @click.stop
    >
      <!-- Â§¥ÈÉ® -->
      <div class="dialog-header">
        <div class="header-content">
          <div class="header-icon">
            <span class="icon">üìê</span>
          </div>
          <div class="header-text">
            <h3 class="header-title">{{ title || t.beautiful.title }}</h3>
            <p class="header-subtitle">{{ subtitle || t.beautiful.subtitle }}</p>
          </div>
          <div class="header-badge">
            <span>LaTeX</span>
          </div>
        </div>
        <button class="close-btn" @click="handleClose">
          <span>√ó</span>
        </button>
      </div>

      <!-- ÁºñËæëÂô®ÂÜÖÂÆπ -->
      <div class="editor-container">
        <!-- ËæìÂÖ•Âå∫Âüü -->
        <div class="input-section">
          <div class="section-header">
            <div class="section-title">
              <span class="icon">üìù</span>
              <span>{{ t.beautiful.inputSection }}</span>
            </div>
            <div class="input-actions">
              <button 
                v-if="availableLocales.length > 1"
                class="action-btn" 
                @click="toggleLanguage" 
                :title="locale === 'zh-CN' ? 'Switch to English' : 'ÂàáÊç¢Âà∞‰∏≠Êñá'"
              >
                <span class="icon">üåê</span>
              </button>
              <button 
                v-if="showThemeToggle"
                class="action-btn" 
                @click="toggleTheme" 
                :title="internalTheme === 'dark' ? t.beautiful.themeToggle.light : t.beautiful.themeToggle.dark"
              >
                <span class="icon">{{ themeIcon }}</span>
              </button>
              <button 
                v-if="showClearButton && !readonly"
                class="action-btn" 
                @click="clearInput" 
                :title="t.beautiful.clearButton"
              >
                <span class="icon">üóëÔ∏è</span>
              </button>
            </div>
          </div>
          <div class="input-wrapper">
            <textarea
              v-model="latexInput"
              class="latex-input"
              :placeholder="computedPlaceholder"
              :readonly="readonly"
              :rows="rows"
              :maxlength="maxLength"
              @input="handleInput"
            ></textarea>
          </div>
        </div>

        <!-- È¢ÑËßàÂå∫Âüü -->
        <div v-if="showPreview" class="preview-section">
          <div class="section-header">
            <div class="section-title">
              <span class="icon">üëÅÔ∏è</span>
              <span>{{ t.beautiful.previewSection }}</span>
            </div>
            <div class="preview-status" :class="{ active: latexInput }">
              <span v-if="latexInput" class="status-dot"></span>
              {{ latexInput ? t.beautiful.rendering : t.beautiful.noFormula }}
            </div>
          </div>
          <div class="preview-container">
            <div v-if="latexInput" class="formula-preview" v-html="renderedFormula"></div>
            <div v-else class="no-formula">
              <span class="icon">üí°</span>
              <span>{{ t.beautiful.inputPlaceholder }}</span>
            </div>
          </div>
        </div>

        <!-- Á¨¶Âè∑Èù¢Êùø -->
        <div v-if="showSymbols" class="symbols-section">
          <!-- ÂàÜÁ±ªÊ†áÁ≠æ -->
          <div class="category-tabs">
            <button
              v-for="category in filteredCategories"
              :key="category.key"
              :class="['tab-button', { active: activeCategory === category.key }]"
              @click="activeCategory = category.key"
            >
              <span class="tab-icon">{{ category.icon }}</span>
              <span class="tab-name">{{ getCategoryName(category, locale) }}</span>
            </button>
          </div>

          <!-- Á¨¶Âè∑ÂÜÖÂÆπ -->
          <div class="symbols-content">
            <!-- Á¨¶Âè∑ÁΩëÊ†º -->
            <div class="symbols-grid">
              <button
                v-for="symbol in currentSymbols"
                :key="symbol.latex"
                class="symbol-button"
                @click="insertSymbol(symbol.latex)"
                :title="getSymbolDescription(symbol, locale)"
              >
                <span v-if="symbol.display" v-html="symbol.display"></span>
                <span v-else class="symbol-fallback">{{ symbol.latex }}</span>
              </button>
            </div>

            <!-- Â∏∏Áî®ÂÖ¨ÂºèÁ§∫‰æã -->
            <div v-if="activeCategory === 'basic' && showFormulaExamples" class="formula-examples">
              <div class="examples-header">
                <span class="icon">‚≠ê</span>
                <span>{{ t.beautiful.categories.formulas }}</span>
              </div>
              <div class="examples-grid">
                <button
                  v-for="example in reactiveFormulaExamples"
                  :key="example.latex"
                  class="example-button"
                  @click="insertSymbol(example.latex)"
                  :title="getSymbolDescription(example, locale)"
                >
                  <div class="example-preview" v-html="example.display"></div>
                  <div class="example-description">{{ getSymbolDescription(example, locale) }}</div>
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Â∫ïÈÉ®Êìç‰ΩúÔºàÂºπÁ™óÊ®°ÂºèÔºâ -->
      <div class="dialog-footer">
        <button class="btn btn-secondary" @click="handleClose">{{ t.beautiful.cancelButton }}</button>
        <button 
          class="btn btn-primary" 
          @click="handleInsert" 
          :disabled="!latexInput || readonly"
        >
          {{ t.beautiful.insertButton }}
        </button>
      </div>
    </div>
  </div>
  </Teleport>
</template>

<script setup lang="ts">
import { ref, computed, watch, onMounted, nextTick } from 'vue';
import { initMathJax } from '../../utils/latex';
import { useI18n } from '../../composables/useI18n';
import {
  type Symbol,
  type Category,
  basicSymbols,
  greekSymbols,
  advancedSymbols,
  formulaExamples,
  categories,
  getSymbolDescription,
  getCategoryName,
} from '../../data';

const props = withDefaults(
  defineProps<{
    // Âü∫Á°ÄÊéßÂà∂
    modelValue?: boolean;
    existingLatex?: string;
    inlineMode?: boolean;
    
    // ‰∏ªÈ¢òÂíåÊ†∑Âºè
    theme?: string;
    width?: string;
    height?: string;
    scale?: number;
    fontSize?: string;
    
    // ÂäüËÉΩÊéßÂà∂
    readonly?: boolean;
    showSymbols?: boolean;
    showPreview?: boolean;
    showThemeToggle?: boolean;
    showClearButton?: boolean;
    showFormulaExamples?: boolean;
    autoFocus?: boolean;
    
    // ËæìÂÖ•ÊéßÂà∂
    placeholder?: string;
    maxLength?: number;
    rows?: number;
    
    // Á¨¶Âè∑Èù¢ÊùøÊéßÂà∂
    enabledCategories?: string[];
    defaultCategory?: string;
    
    // ÊåâÈíÆÊñáÊú¨Ëá™ÂÆö‰πâ
    insertButtonText?: string;
    cancelButtonText?: string;
    clearButtonText?: string;
    
    // Ê†áÈ¢òËá™ÂÆö‰πâ
    title?: string;
    subtitle?: string;
  }>(),
  {
    modelValue: false,
    existingLatex: '',
    inlineMode: false,
    theme: 'light',
    width: 'auto',
    height: 'auto',
    scale: 1.2,
    fontSize: '16px',
    readonly: false,
    showSymbols: true,
    showPreview: true,
    showThemeToggle: true,
    showClearButton: true,
    showFormulaExamples: true,
    autoFocus: true,
    placeholder: '',
    maxLength: 1000,
    rows: 3,
    enabledCategories: () => ['basic', 'greek', 'advanced'],
    defaultCategory: 'basic',
    insertButtonText: 'ÊèíÂÖ•ÂÖ¨Âºè',
    cancelButtonText: 'ÂèñÊ∂à',
    clearButtonText: 'Ê∏ÖÁ©∫',
    title: 'Êï∞Â≠¶ÂÖ¨ÂºèÁºñËæëÂô®',
    subtitle: '‰ΩøÁî®‰∏ãÊñπÊåâÈíÆÊàñÁõ¥Êé•ËæìÂÖ• LaTeX ‰ª£Á†Å',
  }
);

const emit = defineEmits<{
  'update:modelValue': [value: boolean];
  insert: [latex: string];
  change: [latex: string];
  clear: [];
  close: [];
  themeChange: [theme: string];
}>();

// ÂõΩÈôÖÂåñ
const { t, locale, setLocale, availableLocales } = useI18n();

// ÂìçÂ∫îÂºèÊï∞ÊçÆ
const visible = ref(false);
const latexInput = ref('');
const activeCategory = ref(props.defaultCategory);
const renderedFormula = ref('');
const symbolDisplayCache = new Map<string, string>();

// ÁªÑ‰ª∂ÂÜÖÈÉ®‰∏ªÈ¢òÁä∂ÊÄÅÔºàÁã¨Á´ã‰∫éÂ§ñÈÉ®‰º†ÂÖ•ÁöÑthemeÔºâ
const internalTheme = ref(props.theme || 'light');

// ÂàõÂª∫ÂìçÂ∫îÂºèÁöÑÁ¨¶Âè∑Êï∞ÊçÆÂâØÊú¨
const reactiveBasicSymbols = ref([...basicSymbols]);
const reactiveGreekSymbols = ref([...greekSymbols]);
const reactiveAdvancedSymbols = ref([...advancedSymbols]);
const reactiveFormulaExamples = ref([...formulaExamples]);

// ËÆ°ÁÆóÂ±ûÊÄß
const filteredCategories = computed(() => {
  return categories.filter(category => props.enabledCategories.includes(category.key));
});

const currentSymbols = computed(() => {
  switch (activeCategory.value) {
    case 'greek':
      return reactiveGreekSymbols.value;
    case 'advanced':
      return reactiveAdvancedSymbols.value;
    default:
      return reactiveBasicSymbols.value;
  }
});

// ÂºπÁ™óÊ†∑ÂºèËÆ°ÁÆóÂ±ûÊÄß
const dialogStyle = computed(() => {
  const style: Record<string, string> = {};
  if (props.width !== 'auto') {
    style.width = props.width;
  }
  if (props.height !== 'auto') {
    style.height = props.height;
  }
  return style;
});

// ‰∏ªÈ¢òÁõ∏ÂÖ≥ËÆ°ÁÆóÂ±ûÊÄß
const themeIcon = computed(() => {
  return internalTheme.value === 'dark' ? '‚òÄÔ∏è' : 'üåô';
});

const themeButtonTitle = computed(() => {
  return internalTheme.value === 'dark' ? 'ÂàáÊç¢Âà∞‰∫ÆËâ≤‰∏ªÈ¢ò' : 'ÂàáÊç¢Âà∞ÊöóËâ≤‰∏ªÈ¢ò';
});

// ËÆ°ÁÆóÂåñÁöÑplaceholder
const computedPlaceholder = computed(() => {
  return props.placeholder || t.value.beautiful.inputPlaceholder;
});

// ÁõëÂê¨Âô®
watch(
  () => props.modelValue,
  (newVal) => {
    visible.value = newVal;
    if (newVal) {
      latexInput.value = props.existingLatex || '';
      updatePreview();
      focusInput();
    }
  }
);

watch(
  () => props.existingLatex,
  (newVal) => {
    if ((visible.value || props.inlineMode) && newVal) {
      latexInput.value = newVal;
      updatePreview();
    }
  }
);

// ÁõëÂê¨ÂÜÖËÅîÊ®°ÂºèÂèòÂåñ
watch(
  () => props.inlineMode,
  (newVal) => {
    if (newVal) {
      // ÂÜÖËÅîÊ®°ÂºèÊøÄÊ¥ªÊó∂ÔºåÁ°Æ‰øùÁ¨¶Âè∑Â∑≤Ê∏≤Êüì
      nextTick(async () => {
        try {
          // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÈáçÊñ∞Ê∏≤ÊüìÁ¨¶Âè∑
          const needsRender =
            reactiveBasicSymbols.value.some((symbol) => !symbol.display) ||
            reactiveGreekSymbols.value.some((symbol) => !symbol.display) ||
            reactiveAdvancedSymbols.value.some((symbol) => !symbol.display) ||
            reactiveFormulaExamples.value.some((example) => !example.display);

          if (needsRender && window.MathJax?.tex2svgPromise) {
            await Promise.all([renderAllSymbols(), renderFormulaExamples()]);
          }
        } catch (error) {
          console.error('ÂÜÖËÅîÊ®°ÂºèÁ¨¶Âè∑Ê∏≤ÊüìÂ§±Ë¥•:', error);
        }
      });
    }
  },
  { immediate: true }
);

// Ê†áËÆ∞Áî®Êà∑ÊòØÂê¶ÊâãÂä®‰øÆÊîπËøá‰∏ªÈ¢ò
const hasUserChangedTheme = ref(false);

// ÁõëÂê¨Â§ñÈÉ®‰∏ªÈ¢òÂèòÂåñÔºà‰ªÖÂú®ÂàùÂßãÂåñÊó∂ÂêåÊ≠•Ôºå‰πãÂêéÁªÑ‰ª∂ÂÜÖÈÉ®Áã¨Á´ãÊéßÂà∂Ôºâ
watch(
  () => props.theme,
  (newTheme) => {
    // Âè™ÊúâÂú®ÁªÑ‰ª∂ÂÜÖÈÉ®‰∏ªÈ¢òËøòÊ≤°ÊúâË¢´Áî®Êà∑ÊâãÂä®‰øÆÊîπÊó∂ÊâçÂêåÊ≠•Â§ñÈÉ®‰∏ªÈ¢ò
    if (!hasUserChangedTheme.value) {
      internalTheme.value = newTheme;
    }
  },
  { immediate: true }
);

// ÁõëÂê¨ÂÜÖÈÉ®‰∏ªÈ¢òÂèòÂåñ
watch(internalTheme, (newTheme, oldTheme) => {
  if (oldTheme !== undefined) {
    hasUserChangedTheme.value = true;
  }
});

// ÁõëÂê¨ÂêØÁî®ÁöÑÂàÜÁ±ªÂèòÂåñÔºåÁ°Æ‰øùÂΩìÂâçÂàÜÁ±ªÊúâÊïà
watch(
  () => props.enabledCategories,
  (newCategories) => {
    if (!newCategories.includes(activeCategory.value)) {
      activeCategory.value = newCategories[0] || 'basic';
    }
  },
  { immediate: true }
);

// ÊñπÊ≥ï
const handleOverlayClick = () => {
  handleClose();
};

const handleClose = () => {
  visible.value = false;
  emit('update:modelValue', false);
  emit('close');
  if (!props.readonly) {
    latexInput.value = '';
    renderedFormula.value = '';
  }
};

const clearInput = () => {
  if (props.readonly) return;
  latexInput.value = '';
  renderedFormula.value = '';
  emit('clear');
  emit('change', '');
};

const insertSymbol = (symbol: string) => {
  if (props.readonly) return;
  
  // Ê£ÄÊü•ÊúÄÂ§ßÈïøÂ∫¶ÈôêÂà∂
  if (props.maxLength && (latexInput.value + symbol).length > props.maxLength) {
    return;
  }
  
  const textarea = document.querySelector('.latex-input') as HTMLTextAreaElement;
  if (textarea) {
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const currentValue = latexInput.value;

    latexInput.value = currentValue.substring(0, start) + symbol + currentValue.substring(end);

    nextTick(() => {
      textarea.focus();
      textarea.selectionStart = textarea.selectionEnd = start + symbol.length;
      updatePreview();
    });
  } else {
    latexInput.value += symbol;
    updatePreview();
  }
};

const updatePreview = async () => {
  
  // ÂèëÂá∫change‰∫ã‰ª∂
  emit('change', latexInput.value);

  if (!latexInput.value.trim()) {
    renderedFormula.value = '';
    return;
  }

  try {
    // Á°Æ‰øùMathJaxÂ∑≤ÁªèÂàùÂßãÂåñ
    if (!window.MathJax?.tex2svgPromise) {
      await initMathJax();
    }

    // ÂÜçÊ¨°Ê£ÄÊü•MathJaxÊòØÂê¶ÂèØÁî®
    if (!window.MathJax?.tex2svgPromise) {
      console.error('MathJaxÂàùÂßãÂåñÂ§±Ë¥•ÔºåÊó†Ê≥ïÈ¢ÑËßàÂÖ¨Âºè');
      renderedFormula.value = '<span style="color: red;">MathJaxÊú™Âä†ËΩΩ</span>';
      return;
    }

    const result = await window.MathJax.tex2svgPromise(latexInput.value, {
      display: false,
      scale: props.scale,
    });


    const svg = result.getElementsByTagName('svg')[0];
    if (svg) {
      svg.style.fontSize = props.fontSize;
      svg.style.verticalAlign = 'middle';
      renderedFormula.value = svg.outerHTML;
    } else {
      console.warn('Êú™Ëé∑ÂèñÂà∞SVGÂÖÉÁ¥†');
      renderedFormula.value = '<span style="color: red;">Ê∏≤ÊüìÂ§±Ë¥•</span>';
    }
  } catch (error) {
    console.error('LaTeXÈ¢ÑËßàÂ§±Ë¥•:', error);
    const errorMessage = error instanceof Error ? error.message : 'Êú™Áü•ÈîôËØØ';
    renderedFormula.value = `<span style="color: red;">È¢ÑËßàÂ§±Ë¥•: ${errorMessage}</span>`;
  }
};

const handleInsert = () => {
  if (latexInput.value.trim()) {
    emit('insert', latexInput.value.trim());
    if (!props.inlineMode) {
      handleClose();
    }
  }
};

// ‰∏ªÈ¢òÂàáÊç¢ÊñπÊ≥ïÔºà‰ªÖÂΩ±ÂìçÂΩìÂâçÁªÑ‰ª∂Ôºâ
const toggleTheme = () => {
  if (!props.showThemeToggle) return;
  const newTheme = internalTheme.value === 'dark' ? 'light' : 'dark';
  internalTheme.value = newTheme;
  emit('themeChange', newTheme);
};

// ËØ≠Ë®ÄÂàáÊç¢ÊñπÊ≥ï
const toggleLanguage = () => {
  const newLocale = locale.value === 'zh-CN' ? 'en-US' : 'zh-CN';
  setLocale(newLocale);
};

// Â§ÑÁêÜËæìÂÖ•ÂèòÂåñ
const handleInput = (event: Event) => {
  if (props.readonly) {
    event.preventDefault();
    return;
  }
  
  const target = event.target as HTMLTextAreaElement;
  let value = target.value;
  
  // Â∫îÁî®ÊúÄÂ§ßÈïøÂ∫¶ÈôêÂà∂
  if (props.maxLength && value.length > props.maxLength) {
    value = value.substring(0, props.maxLength);
    target.value = value;
    latexInput.value = value;
  }
  
  updatePreview();
};

// Ëá™Âä®ËÅöÁÑ¶ÂäüËÉΩ
const focusInput = () => {
  if (props.autoFocus) {
    nextTick(() => {
      const textarea = document.querySelector('.latex-input') as HTMLTextAreaElement;
      if (textarea) {
        textarea.focus();
      }
    });
  }
};

// Ê∏≤ÊüìÁ¨¶Âè∑
const renderSymbols = async (symbols: Symbol[]) => {
  for (let i = 0; i < symbols.length; i++) {
    const symbol = symbols[i];
    if (!symbol.display) {
      try {
        if (window.MathJax?.tex2svgPromise) {

          const result = await window.MathJax.tex2svgPromise(symbol.latex, {
            display: false,
            scale: 1.3,
            em: 16,
            ex: 8,
            containerWidth: 1280,
          });

          const svg = result.getElementsByTagName('svg')[0];
          if (svg) {
            // ÊèêÂçáSVGÊ∏≤ÊüìË¥®Èáè
            svg.style.fontSize = '18px';
            svg.style.verticalAlign = 'middle';
            svg.style.maxWidth = '32px';
            svg.style.maxHeight = '32px';
            svg.style.width = 'auto';
            svg.style.height = 'auto';

            // ËÆæÁΩÆSVGÂ±ûÊÄß‰ª•ÊèêÈ´òÊ∏≤ÊüìË¥®Èáè
            svg.setAttribute('shape-rendering', 'geometricPrecision');
            svg.setAttribute('text-rendering', 'optimizeLegibility');

            symbol.display = svg.outerHTML;
          } else {
            symbol.display = '';
          }
        }
      } catch (error) {
        console.warn(`Á¨¶Âè∑ ${symbol.latex} Ê∏≤ÊüìÂ§±Ë¥•:`, error);
        // Â¶ÇÊûúÊ∏≤ÊüìÂ§±Ë¥•Ôºå‰ΩøÁî®Á©∫Â≠óÁ¨¶‰∏≤ÔºåËÆ©ÂêéÂ§áÊñáÊú¨ÊòæÁ§∫
        symbol.display = '';
      }

      // Ê∑ªÂä†Â∞èÂª∂ËøüÈÅøÂÖçËøáÂø´Ê∏≤ÊüìÂØºËá¥ÁöÑÈóÆÈ¢ò
      await new Promise((resolve) => setTimeout(resolve, 50));
    }
  }
};

// Ê∏≤ÊüìÊâÄÊúâÁ¨¶Âè∑
const renderAllSymbols = async () => {  

  // Ê£ÄÊü•MathJaxÊòØÂê¶ÂèØÁî®
  if (!window.MathJax?.tex2svgPromise) {
    console.warn('MathJax‰∏çÂèØÁî®ÔºåË∑≥ËøáÁ¨¶Âè∑Ê∏≤Êüì');
    return;
  }

  try {
    // ‰∏≤Ë°åÊ∏≤ÊüìÈÅøÂÖçÂπ∂ÂèëÈóÆÈ¢ò
    await renderSymbols(reactiveBasicSymbols.value);

    await renderSymbols(reactiveGreekSymbols.value);

    await renderSymbols(reactiveAdvancedSymbols.value);

  } catch (error) {
    console.error('Á¨¶Âè∑Ê∏≤ÊüìËøáÁ®ã‰∏≠Âá∫Èîô:', error);
  }
};

// Ê∏≤ÊüìÂÖ¨ÂºèÁ§∫‰æã
const renderFormulaExamples = async () => {

  if (!window.MathJax?.tex2svgPromise) {
    return;
  }

  for (let i = 0; i < reactiveFormulaExamples.value.length; i++) {
    const example = reactiveFormulaExamples.value[i];
    if (!example.display) {
      try {

        const result = await window.MathJax.tex2svgPromise(example.latex, {
          display: false,
          scale: 1.0,
          em: 16,
          ex: 8,
          containerWidth: 1280,
        });

        const svg = result.getElementsByTagName('svg')[0];
        if (svg) {
          svg.style.fontSize = '16px';
          svg.style.maxWidth = '100%';
          svg.style.verticalAlign = 'middle';

          // ËÆæÁΩÆSVGÂ±ûÊÄß‰ª•ÊèêÈ´òÊ∏≤ÊüìË¥®Èáè
          svg.setAttribute('shape-rendering', 'geometricPrecision');
          svg.setAttribute('text-rendering', 'optimizeLegibility');

          example.display = svg.outerHTML;
        } else {
          example.display = '';
        }
      } catch (error) {
        console.warn(`ÂÖ¨ÂºèÁ§∫‰æã ${example.latex} Ê∏≤ÊüìÂ§±Ë¥•:`, error);
        example.display = '';
      }

      // Ê∑ªÂä†Â∞èÂª∂Ëøü
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
  }

};

// ÁîüÂëΩÂë®Êúü
onMounted(async () => {
  
  // Â¶ÇÊûúÊòØÂÜÖËÅîÊ®°ÂºèÊàñËÄÖÂºπÁ™óÂ∑≤ÊòæÁ§∫ÔºåÂàôÊâßË°åËá™Âä®ËÅöÁÑ¶
  if (props.inlineMode || visible.value) {
    focusInput();
  }
  
  try {
    await initMathJax();

    // Á≠âÂæÖ‰∏ÄÊÆµÊó∂Èó¥Á°Æ‰øùMathJaxÂÆåÂÖ®Â∞±Áª™
    await new Promise((resolve) => setTimeout(resolve, 300));

    // Âπ∂Ë°åÊ∏≤ÊüìÁ¨¶Âè∑ÂíåÂÖ¨ÂºèÁ§∫‰æã
    await Promise.all([renderAllSymbols(), renderFormulaExamples()]);

  } catch (error) {
    console.error('VueMathjaxBeautifulÂàùÂßãÂåñÂ§±Ë¥•:', error);
  }
});
</script>

<style lang="scss">
/* ÊâÄÊúâÊ†∑ÂºèÂ∑≤ÁßªËá≥ packages/core/src/styles/index.scss ‰∏≠Áªü‰∏ÄÁÆ°ÁêÜ */
</style>
